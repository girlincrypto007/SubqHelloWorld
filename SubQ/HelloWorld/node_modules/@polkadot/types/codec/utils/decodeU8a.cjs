"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.decodeU8a = decodeU8a;

var _util = require("@polkadot/util");

// Copyright 2017-2021 @polkadot/types authors & contributors
// SPDX-License-Identifier: Apache-2.0
function formatFailure(error, key, type, u8a) {
  return `decodeU8a: failed at ${(0, _util.u8aToHex)(u8a)}â€¦${key ? ` on ${key}` : ''}${type ? `: ${type}` : ''}:: ${error.message}`;
}

function getRawType(registry, Type) {
  try {
    return new Type(registry).toRawType();
  } catch {
    return '';
  }
}
/**
 * Given an u8a, and an array of Type constructors, decode the u8a against the
 * types, and return an array of decoded values.
 *
 * @param u8a - The u8a to decode.
 * @param result - The result array (will be returned with values pushed)
 * @param types - The array of Constructor to decode the U8a against.
 */


function decodeU8a(registry, u8a, types, count, zip) {
  const [Type, Types, keys] = (0, _util.isFunction)(types) ? [types, [], []] : Array.isArray(types) ? [null, types, []] : [null, Object.values(types), Object.keys(types)];
  count = count || Types.length;
  const result = new Array(count);
  let offset = 0;

  for (let i = 0; i < count; i++) {
    try {
      const value = new (Type || Types[i])(registry, u8a.subarray(offset));
      offset += value.initialU8aLength || value.encodedLength;
      result[i] = zip ? zip(keys[i], value) : value;
    } catch (error) {
      throw new Error(formatFailure(error, keys[i], getRawType(registry, Type || Types[i]), u8a.subarray(offset, offset + 8)));
    }
  }

  return [result, offset];
}