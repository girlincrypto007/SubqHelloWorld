"use strict";
// Copyright 2020-2021 OnFinality Limited authors & contributors
// SPDX-License-Identifier: Apache-2.0
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const fs_1 = require("fs");
const path_1 = (0, tslib_1.__importDefault)(require("path"));
const command_1 = require("@oclif/command");
const webpack_1 = (0, tslib_1.__importDefault)(require("webpack"));
const webpack_merge_1 = require("webpack-merge");
const validate_1 = (0, tslib_1.__importDefault)(require("./validate"));
const getBaseConfig = (dir, outputPath, development) => ({
    target: 'node',
    mode: development ? 'development' : 'production',
    entry: path_1.default.join(dir, 'src/index.ts'),
    devtool: development && 'inline-source-map',
    module: {
        rules: [
            {
                test: /\.tsx?$/,
                exclude: /node_modules/,
                loader: require.resolve('ts-loader'),
                options: {
                    compilerOptions: {
                        declaration: false,
                    },
                },
            },
        ],
    },
    resolve: {
        extensions: ['.tsx', '.ts', '.js'],
    },
    output: {
        path: path_1.default.dirname(outputPath),
        filename: path_1.default.basename(outputPath),
        libraryTarget: 'commonjs',
        clean: true,
    },
});
class Build extends command_1.Command {
    async run() {
        const { flags } = this.parse(Build);
        const directory = flags.location ? path_1.default.resolve(flags.location) : process.cwd();
        const isDev = flags.mode === 'development' || flags.mode === 'dev';
        if (!(0, fs_1.lstatSync)(directory).isDirectory()) {
            this.error('Argument `location` is not a valid directory');
        }
        // Check that we're in a valid project
        try {
            await validate_1.default.run(['--silent', '--location', directory]);
        }
        catch (e) {
            this.error('Directory is not a valid project');
        }
        // Get the output location from the project package.json main field
        const pjson = JSON.parse((0, fs_1.readFileSync)(path_1.default.join(directory, 'package.json')).toString());
        const outputPath = path_1.default.resolve(directory, pjson.main || 'dist/index.js');
        const config = (0, webpack_merge_1.merge)(getBaseConfig(directory, outputPath, isDev)
        // Can allow projects to override webpack config here
        );
        // Use webpack to build TS code and package into a single file
        this.log(`Building code${isDev ? ' with development mode' : ''}`);
        await new Promise((resolve, reject) => {
            (0, webpack_1.default)(config).run((error, stats) => {
                if (error) {
                    reject(error);
                    this.log(error.message);
                    return;
                }
                if (stats.hasErrors()) {
                    const info = stats.toJson();
                    reject(info.errors[0]);
                    this.log(info.errors[0].details);
                    return;
                }
                this.log('Finished building code');
                resolve(true);
            });
        });
    }
}
exports.default = Build;
Build.description = 'Build this SubQuery project code';
Build.flags = {
    location: command_1.flags.string({ char: 'l', description: 'local folder' }),
    mode: command_1.flags.enum({ options: ['production', 'prod', 'development', 'dev'], default: 'production' }),
};
//# sourceMappingURL=build.js.map