import { ApiPromise } from '@polkadot/api';
import { RegistryTypes } from '@polkadot/types/types';
import { SubstrateBlock, SubstrateEvent, SubstrateExtrinsic } from './interfaces';
export declare enum SubqlDatasourceKind {
    Runtime = "substrate/Runtime"
}
export declare enum SubqlHandlerKind {
    Block = "substrate/BlockHandler",
    Call = "substrate/CallHandler",
    Event = "substrate/EventHandler"
}
declare type RuntimeHandlerInputMap = {
    [SubqlHandlerKind.Block]: SubstrateBlock;
    [SubqlHandlerKind.Event]: SubstrateEvent;
    [SubqlHandlerKind.Call]: SubstrateExtrinsic;
};
declare type RuntimeFilterMap = {
    [SubqlHandlerKind.Block]: SubqlNetworkFilter;
    [SubqlHandlerKind.Event]: SubqlEventFilter;
    [SubqlHandlerKind.Call]: SubqlCallFilter;
};
export interface ProjectManifest {
    specVersion: string;
    description: string;
    repository: string;
    schema: string;
    network: {
        endpoint: string;
        customTypes?: RegistryTypes;
    };
    dataSources: SubqlDatasource[];
}
export declare type SpecVersionRange = [number, number];
interface SubqlBaseHandlerFilter {
    specVersion?: SpecVersionRange;
}
export declare type SubqlBlockFilter = SubqlBaseHandlerFilter;
export interface SubqlEventFilter extends SubqlBaseHandlerFilter {
    module?: string;
    method?: string;
}
export interface SubqlCallFilter extends SubqlEventFilter {
    success?: boolean;
}
export interface SubqlBlockHandler {
    handler: string;
    kind: SubqlHandlerKind.Block;
    filter?: SubqlBlockFilter;
}
export interface SubqlCallHandler {
    handler: string;
    kind: SubqlHandlerKind.Call;
    filter?: SubqlCallFilter;
}
export interface SubqlEventHandler {
    handler: string;
    kind: SubqlHandlerKind.Event;
    filter?: SubqlEventFilter;
}
export interface SubqlCustomHandler<K extends string = string, F = Record<string, unknown>> {
    handler: string;
    kind: K;
    filter?: F;
}
export declare type SubqlRuntimeHandler = SubqlBlockHandler | SubqlCallHandler | SubqlEventHandler;
export declare type SubqlHandler = SubqlRuntimeHandler | SubqlCustomHandler<string, unknown>;
export declare type SubqlHandlerFilter = SubqlBlockFilter | SubqlCallFilter | SubqlEventFilter;
export interface SubqlMapping<T extends SubqlHandler = SubqlHandler> {
    handlers: T[];
}
interface ISubqlDatasource<M extends SubqlMapping, F extends SubqlNetworkFilter = SubqlNetworkFilter> {
    name?: string;
    kind: string;
    filter?: F;
    startBlock?: number;
    mapping: M;
}
export interface SubqlRuntimeDatasource<M extends SubqlMapping<SubqlRuntimeHandler> = SubqlMapping<SubqlRuntimeHandler>> extends ISubqlDatasource<M> {
    kind: SubqlDatasourceKind.Runtime;
}
export interface SubqlNetworkFilter {
    specName?: string;
}
export declare type SubqlDatasource = SubqlRuntimeDatasource | SubqlCustomDatasource;
export interface FileReference {
    file: string;
}
export declare type CustomDataSourceAsset = FileReference;
export interface SubqlCustomDatasource<K extends string = string, T extends SubqlNetworkFilter = SubqlNetworkFilter, M extends SubqlMapping = SubqlMapping<SubqlCustomHandler>> extends ISubqlDatasource<M, T> {
    kind: K;
    assets: Map<string, CustomDataSourceAsset>;
    processor: FileReference;
    abi?: string;
}
export interface HandlerInputTransformer<T extends SubqlHandlerKind, U> {
    (original: RuntimeHandlerInputMap[T], ds: SubqlCustomDatasource, api: ApiPromise, assets: Record<string, string>): Promise<U>;
}
export interface SubqlDatasourceProcessor<K extends string, F extends SubqlNetworkFilter> {
    kind: K;
    validate(ds: SubqlCustomDatasource<K, F>, assets: Record<string, string>): void;
    dsFilterProcessor(ds: SubqlCustomDatasource<K, F>, api: ApiPromise): boolean;
    handlerProcessors: {
        [kind: string]: SecondLayerHandlerProcessor<SubqlHandlerKind, unknown, unknown>;
    };
}
export interface SecondLayerHandlerProcessor<K extends SubqlHandlerKind, F, E> {
    baseHandlerKind: K;
    baseFilter: RuntimeFilterMap[K] | RuntimeFilterMap[K][];
    transformer: HandlerInputTransformer<K, E>;
    filterProcessor: (filter: F, input: E, ds: SubqlCustomDatasource<string, SubqlNetworkFilter>) => boolean;
    filterValidator: (filter: F) => void;
}
export {};
