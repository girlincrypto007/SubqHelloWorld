{"version":3,"file":"project.js","sourceRoot":"","sources":["../src/project.ts"],"names":[],"mappings":";AAAA,gEAAgE;AAChE,sCAAsC;;;AAMtC,0BAA0B;AAC1B,mCAAmC;AACnC,6CAA6C;AAC7C,2CAA2C;AAC3C,6CAA6C;AAC7C,IAAI;AAEJ,IAAY,mBAGX;AAHD,WAAY,mBAAmB;IAC7B,oDAA6B,CAAA;IAC7B,+BAA+B;AACjC,CAAC,EAHW,mBAAmB,GAAnB,2BAAmB,KAAnB,2BAAmB,QAG9B;AAED,IAAY,gBAIX;AAJD,WAAY,gBAAgB;IAC1B,oDAAgC,CAAA;IAChC,kDAA8B,CAAA;IAC9B,oDAAgC,CAAA;AAClC,CAAC,EAJW,gBAAgB,GAAhB,wBAAgB,KAAhB,wBAAgB,QAI3B","sourcesContent":["// Copyright 2020-2021 OnFinality Limited authors & contributors\n// SPDX-License-Identifier: Apache-2.0\n\nimport {ApiPromise} from '@polkadot/api';\nimport {RegistryTypes} from '@polkadot/types/types';\nimport {SubstrateBlock, SubstrateEvent, SubstrateExtrinsic} from './interfaces';\n\n// export enum SubqlKind {\n//   Runtime = 'substrate/Runtime',\n//   BlockHandler = 'substrate/BlockHandler',\n//   CallHandler = 'substrate/CallHandler',\n//   EventHandler = 'substrate/EventHandler',\n// }\n\nexport enum SubqlDatasourceKind {\n  Runtime = 'substrate/Runtime',\n  // Custom = 'substrate/Custom',\n}\n\nexport enum SubqlHandlerKind {\n  Block = 'substrate/BlockHandler',\n  Call = 'substrate/CallHandler',\n  Event = 'substrate/EventHandler',\n}\n\ntype RuntimeHandlerInputMap = {\n  [SubqlHandlerKind.Block]: SubstrateBlock;\n  [SubqlHandlerKind.Event]: SubstrateEvent;\n  [SubqlHandlerKind.Call]: SubstrateExtrinsic;\n};\n\ntype RuntimeFilterMap = {\n  [SubqlHandlerKind.Block]: SubqlNetworkFilter;\n  [SubqlHandlerKind.Event]: SubqlEventFilter;\n  [SubqlHandlerKind.Call]: SubqlCallFilter;\n};\n\nexport interface ProjectManifest {\n  specVersion: string;\n  description: string;\n  repository: string;\n\n  schema: string;\n\n  network: {\n    endpoint: string;\n    customTypes?: RegistryTypes;\n  };\n\n  dataSources: SubqlDatasource[];\n}\n\n// [startSpecVersion?, endSpecVersion?] closed range\nexport type SpecVersionRange = [number, number];\n\ninterface SubqlBaseHandlerFilter {\n  specVersion?: SpecVersionRange;\n}\n\nexport type SubqlBlockFilter = SubqlBaseHandlerFilter;\n\nexport interface SubqlEventFilter extends SubqlBaseHandlerFilter {\n  module?: string;\n  method?: string;\n}\n\nexport interface SubqlCallFilter extends SubqlEventFilter {\n  success?: boolean;\n}\n\nexport interface SubqlBlockHandler {\n  handler: string;\n  kind: SubqlHandlerKind.Block;\n  filter?: SubqlBlockFilter;\n}\n\nexport interface SubqlCallHandler {\n  handler: string;\n  kind: SubqlHandlerKind.Call;\n  filter?: SubqlCallFilter;\n}\n\nexport interface SubqlEventHandler {\n  handler: string;\n  kind: SubqlHandlerKind.Event;\n  filter?: SubqlEventFilter;\n}\n\nexport interface SubqlCustomHandler<K extends string = string, F = Record<string, unknown>> {\n  handler: string;\n  kind: K;\n  filter?: F;\n}\n\nexport type SubqlRuntimeHandler = SubqlBlockHandler | SubqlCallHandler | SubqlEventHandler;\n\nexport type SubqlHandler = SubqlRuntimeHandler | SubqlCustomHandler<string, unknown>;\n\nexport type SubqlHandlerFilter = SubqlBlockFilter | SubqlCallFilter | SubqlEventFilter;\n\nexport interface SubqlMapping<T extends SubqlHandler = SubqlHandler> {\n  handlers: T[];\n}\n\ninterface ISubqlDatasource<M extends SubqlMapping, F extends SubqlNetworkFilter = SubqlNetworkFilter> {\n  name?: string;\n  kind: string;\n  filter?: F;\n  startBlock?: number;\n  mapping: M;\n}\n\nexport interface SubqlRuntimeDatasource<M extends SubqlMapping<SubqlRuntimeHandler> = SubqlMapping<SubqlRuntimeHandler>>\n  extends ISubqlDatasource<M> {\n  kind: SubqlDatasourceKind.Runtime;\n}\n\nexport interface SubqlNetworkFilter {\n  specName?: string;\n}\n\nexport type SubqlDatasource = SubqlRuntimeDatasource | SubqlCustomDatasource; // | SubqlBuiltinDataSource;\n\nexport interface FileReference {\n  file: string;\n}\n\nexport type CustomDataSourceAsset = FileReference;\n\nexport interface SubqlCustomDatasource<\n  K extends string = string,\n  T extends SubqlNetworkFilter = SubqlNetworkFilter,\n  M extends SubqlMapping = SubqlMapping<SubqlCustomHandler>\n> extends ISubqlDatasource<M, T> {\n  kind: K;\n  assets: Map<string, CustomDataSourceAsset>;\n  processor: FileReference;\n  abi?: string; // Should be a key of assets\n}\n\n//export type SubqlBuiltinDataSource = ISubqlDatasource;\n\nexport interface HandlerInputTransformer<T extends SubqlHandlerKind, U> {\n  (\n    original: RuntimeHandlerInputMap[T],\n    ds: SubqlCustomDatasource,\n    api: ApiPromise,\n    assets: Record<string, string>\n  ): Promise<U>; //  | SubqlBuiltinDataSource\n}\n\nexport interface SubqlDatasourceProcessor<K extends string, F extends SubqlNetworkFilter> {\n  kind: K;\n  validate(ds: SubqlCustomDatasource<K, F>, assets: Record<string, string>): void;\n  dsFilterProcessor(ds: SubqlCustomDatasource<K, F>, api: ApiPromise): boolean;\n  handlerProcessors: {[kind: string]: SecondLayerHandlerProcessor<SubqlHandlerKind, unknown, unknown>};\n}\n\n// only allow one custom handler for each baseHandler kind\nexport interface SecondLayerHandlerProcessor<K extends SubqlHandlerKind, F, E> {\n  // kind: string;\n  baseHandlerKind: K;\n  baseFilter: RuntimeFilterMap[K] | RuntimeFilterMap[K][];\n  transformer: HandlerInputTransformer<K, E>;\n  filterProcessor: (filter: F, input: E, ds: SubqlCustomDatasource<string, SubqlNetworkFilter>) => boolean;\n  filterValidator: (filter: F) => void;\n}\n"]}